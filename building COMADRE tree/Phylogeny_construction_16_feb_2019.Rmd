---
title: "Phylogeny_construction"
author: "Kevin Healy"
date: "16/02/2019"
output:
  pdf_document: default
  html_document: default
---

This script builds a set of 100 phylogenies by joining the super trees form xx xx xx together and adding error at each node join based on fossil evidence. This is the set of phylogenies used for the analysis in the paper Healy et al. Beyound the fast-slow continuum.

P.S I cant spell so just go with it.


#Packages and Data
First lets load the packages. Apart from `mulTree`, which is available on github, all other packages are on CRAN
```{r load up packages, include=TRUE}

###mulTree is a package designed to run multiple phylogenies in the MCMCglmm function
#It is available to download from xxxxxx
require(mulTree)

library(devtools)
library(MASS)
library(popbio)
library(popdemo)
library(phytools)

```



Now let load the demography dataset so that we can match up our species with the phylogeny. For the paper we used a version of COMADRE which was released with the publication, however, check xxx for potential updates.
```{r load data, include=TRUE}

load("COMADRE_vX.RData")

```


Now lets load some functions that were built for this job. 
Demography_functions has functions related to calulating demography elements
phylo_bind_functions has functions to build the phylogenies and include error in the nodes joining together trees.

```{r load additional functions, include=TRUE}

source("Demography_functions.R")

source("phylo_bind_functions.R")

```


Lets now upload each of the phylogenies we are going to use to build our superdooper tree

```{r load trees, include=TRUE}

#the metazoan tree as a backbone is from xxxx
met_tree <- read.tree("metazoa.tre")
met_tree  <- makeLabel(met_tree) 

#the mammal tree is from xxxx
mammal_phy <- read.nexus("FritzTree.rs200k.100trees.tre")

#the aves tree is from xxxx
aves_phy <- read.tree("BirdzillaHackett10.tre")

#the lizard tree is from xxxx
Lizard_phy <- read.tree("liz_and_snake_time_tree.txt")
#the makeLabel functions deals with a dublicated name problem caused by polynomies in the tree
lizard_phy<-makeLabel(Lizard_phy)
lizard_phy<-makeLabel(lizard_phy)


# lets also set the number of trees we will build. 
# As we will have to drop trees due to the inclusion of uncertinatly in node age 
# creating trees that dont corresponse with the structure of our backbone phylogeny
# we need to more than 100
sample.no <- 300
```

#Species to match


We run the same code to subset the species in the COMPADRE dataset so that we have the same species in our phylogeny as in our analysis.
```{r load demography data, include=TRUE}


pooled_Metadata <- (subset(comadre$metadata, 
                           MatrixComposite == "Pooled"
                           & MatrixDimension >= 2 
                           & StudyDuration >= 2 
                           & MatrixSplit == "Divided" 
                           & MatrixFec == "Yes" 
                           & MatrixTreatment == "Unmanipulated"
                           & AnnualPeriodicity == "1"
))

mean_Metadata <- (subset(comadre$metadata,
                         MatrixComposite == "Mean" 
                         & MatrixDimension >= 2 
                         & StudyDuration >= 2 
                         & MatrixSplit == "Divided" 
                         & MatrixFec == "Yes" 
                         & MatrixTreatment == "Unmanipulated"
                         & AnnualPeriodicity == "1"
))


combined_data <- rbind(pooled_Metadata, mean_Metadata )
keep_first <- as.numeric(rownames(combined_data))

species_list <- data.frame(species =(combined_data$SpeciesAccepted), class = (combined_data$Class), phyla = (combined_data$Phylum), stringsAsFactors=FALSE )
#add humans
human_list <- c(species = "Homo_sapiens", class = "Mammalia", phyla = "Chordata" )
species_list <- rbind(species_list, human_list)

species_list_u <- unique(species_list$species)

clean_species <- comadre$metadata[keep_first,]$SpeciesAccepted
species_clean_list_u <- unique(clean_species)

full_uni <- data.frame(species_grep = species_clean_list_u, 
                       species = species_clean_list_u , 
                       species_match = rep(0, length(unique(species_clean_list_u))), 
                       matched = rep(0, length(unique(species_clean_list_u))), 
                       taxonomic_class = rep(0, length(unique(species_clean_list_u))),
                       stringsAsFactors=FALSE)

##add_humans
human_list_u <- c(species_grep = "Homo_sapiens", species = "Homo_sapiens", 0,0,0)
full_uni <- rbind(full_uni, human_list_u)

```

We then clean the species names to put it in a formate that can be matched with the phylogeny names.

```{r clean species names, include=TRUE}

###remove all the subspecies information
full_uni[,1]  <- gsub(" subsp.*","", full_uni[,1])
full_uni[,1]  <- gsub(" ","_", full_uni[,1])

species_list[,1]  <- gsub(" subsp.*","", species_list[,1])
species_list[,1]  <- gsub(" ","_", species_list[,1])
```


We now match up the species names from COMADRE with those in the backbone tree
```{r match species names to backbone tree, include=TRUE}

###this pulls out all the entries in the open tree of life phylogeny that correspond with the species names in our COMADRE species list.
for(i in 1:( length(full_uni[,1]))){
  if(any(grep(full_uni[i,1], met_tree$tip.label)) == T){
    full_uni[i,3]  <- met_tree$tip.label[grep(full_uni[i,1], met_tree$tip.label)][1]
    full_uni[i,4]  <- "yes"
  }
  
  else{
    full_uni[i,3]  <- full_uni[i,1]
    full_uni[i,4]  <- "no"
    full_uni[i,5] <- species_list[species_list$speciesAcc == c(full_uni[i,2]),"class"][1]
  }
}


###addition of Class information
for(i in 1:( length(full_uni[,1]))){
  
  full_uni[i,5] <- as.vector(species_list[(grep(full_uni[i,1],species_list[,1]))[1],"class"])
}

####remove any dubicates that might have arise from sub-species
full_uni <- full_uni[which(duplicated(full_uni$species_match) == FALSE),]

full_uni <- data.frame(full_uni,species_two = rep(0, length(full_uni[,1])))

```


Now we match up the species from the taxinomic groups in our dataset which we dont have a dated phylogeny.
```{r match taxons, include=TRUE}
###for taxinomic groups without a dated tree we need to handle them more directly
taxa_ott_match <- full_uni[full_uni$taxonomic_class %in% c("Actinopterygii","Amphibia","Anthozoa", "Bivalvia", "Insecta",
                                                           "Demospongiae", "Elasmobranchii", "Gastropoda", "Malacostraca"),
                           "species_match"]
###we also need to take out the tutle and croc species as these are not in the reptile phylogeny
turt_names <- c("Caretta_caretta_ott392505", "Chelodina_expansa_ott642964", "Chelydra_serpentina_ott587311", 
                "Chrysemys_picta_marginata_ott801475","Clemmys_guttata_ott436621", "Emydura_macquarii_krefftii_ott687926", 
                "Kinosternon_subrubrum_steindachneri_ott5223436", "Malaclemys_terrapin_terrapin_ott227420", 
                "Podocnemis_expansa_ott709468", "Sternotherus_odoratus_ott487672",
                "Kinosternon_integrum_ott944915", "Kinosternon_flavescens_spooneri_ott487666",
                "Podocnemis_lewyana_ott211855")

cror_names <- c("Crocodylus_johnsoni_ott458978", "Crocodylus_niloticus_ott35864")

###change the names for the species within reptiles (i.e turtles)
species_ott_match <- full_uni[full_uni$species_match %in% turt_names,"species_match"]
species_ott_match_croc <- full_uni[full_uni$species_match %in% cror_names,"species_match"]


tot_ott <- unlist(list(taxa_ott_match, species_ott_match, species_ott_match_croc))

species_two <- vector()

###this  re-reads the above species back into a list of matched names
for(i in 1:(length(full_uni$species_match))){
  if(any(full_uni$species_match[i] == tot_ott) == T) {
    species_two[i] <- full_uni$species_match[i]
  } else{
    species_two[i] <- as.vector(full_uni$species_grep[i])
  }
}
```


Next we deal with the synomoms in the aves phylogeny
```{r aves synomoms, include=TRUE}

#####The following species need to be named to match the phylogenies.
###changes for Jetz
species_two[species_two == "Thalassarche_melanophris"] <- "Thalassarche_melanophrys"
species_two[species_two == "Anser_caerulescens"] <- "Chen_caerulescens"
species_two[species_two == "Anthropoides_paradiseus"] <- "Grus_paradisea"
species_two[species_two == "Setophaga_cerulea"] <- "Dendroica_cerulea"
species_two[species_two == "Sternula_antillarum"] <- "Sterna_antillarum"

###changes for Prion phylgeny
species_two[species_two == "Cryptophis_nigrescens"] <- "Rhinoplocephalus_nigrescens"
species_two[species_two == "Drymarchon_couperi"] <- "Drymarchon_corais"

##Hoplocephalus_bitorquatus is actually one of three species in the genus so as long as that is not in it of Hoplocephalus stephensii 
##so as long as that is not in it of Hoplocephalus stephensii its fine
species_two[species_two == "Hoplocephalus_bungaroides"] <- "Hoplocephalus_bitorquatus"


####changes for mammal phylogeny
species_two[species_two == "Callospermophilus_lateralis"] <- "Spermophilus_lateralis"
species_two[species_two == "Urocitellus_columbianus"] <- "Spermophilus_columbianus"
species_two[species_two == "Urocitellus_armatus"] <- "Spermophilus_armatus"
species_two[species_two == "Urocitellus_beldingi"] <- "Spermophilus_beldingi"
species_two[species_two == "Physeter_macrocephalus"] <- "Physeter_catodon"


####some studies have these as seperate species, however we will assume they are the same as Antechinus_stuartii is not in the  dataset
species_two[species_two == "Antechinus_agilis"] <- "Antechinus_stuartii"


full_uni$species_two <- species_two

```

We now start with aves and work backward adding each taxinomic groups and there phylogeny as we meet them. First up is the common ancestor between the two crocodiles species in our analysis

We scale the tree using the Grafen transformation to refect the divergence time for the last common ancestor between our cros species which is between 10.77mya and 16.7mya. See Srikulnath, K; Thapana, W; Muangmai, N (2015). "Role of chromosome changes in Crocodylus evolution and diversity".Genomics Inform. 13 (4): 102–111.

```{r croc it up, include=TRUE}
full_mcl_croc <- full_uni[(full_uni$species_two %in% cror_names),]
fin_croc <- comparative.data(phy = met_tree, data = full_mcl_croc, names.col = "species_match" , force.root = TRUE)
tree_croc <-compute.brlen(fin_croc $phy, method = "Grafen", power = 1)

tree_croc$edge.length <- tree_croc$edge.length*13.735

```

We now graft these two sepcies onto the aves tree with error using our jiggle.bind function.
```{r croc v aves, include=TRUE}

croc_bird_o <- jiggle.bind(x = tree_croc, 
            y = aves_phy, 
            sample = sample.no, 
            min.age = 186, max.age = 249)
croc_bird <- croc_bird_o[[1]]
croc_bird_ages <- croc_bird_o[[2]]
```


Using the last tree we graft on the nest group, the tutles. We use a spit between the Pleurodira and the Cryptodira as 100mya.
The common ancestor between aves/cros and turtles was taken from http://onlinelibrary.wiley.com/doi/10.1111/ede.12081/full


```{r croc_aves v tutles, include=TRUE}

###now add turtles
full_mcl_turt <- full_uni[(full_uni$species_two %in% turt_names),]
fin_turt <- comparative.data(phy = met_tree, data = full_mcl_turt, names.col = "species_match" , force.root = TRUE)
tree_turt <-compute.brlen(fin_turt $phy, method = "Grafen", power = 1)

tree_turt$edge.length <- tree_turt$edge.length*157


turt_bird_o <- jiggle.bind(x = croc_bird, 
                         y = tree_turt, 
                         sample = sample.no, 
                         min.age = 233, max.age = 274)
turt_bird <- turt_bird_o[[1]]
turt_bird_ages <- turt_bird_o[[2]]

```

Next we add the lepidosaurs (add this in from the supp)

```{r croc_aves_tutles v lepidosaurs, include=TRUE}


liz_turt_bird_o <- jiggle.bind(x = lizard_phy, 
                         y = turt_bird, 
                         sample = sample.no, 
                         min.age = 259, max.age = 285)

liz_turt_bird <- liz_turt_bird_o[[1]]
liz_turt_bird_ages <- liz_turt_bird_o[[2]]


```


Nex the mammals
```{r croc_aves_tutles_lepidosaurs v mammals, include=TRUE}

amniote_tree_o <- jiggle.bind(x = liz_turt_bird, 
                             y = mammal_phy, 
                             sample = sample.no, 
                             min.age = 314.6, max.age = 318.1)

amniote_tree <- amniote_tree_o[[1]]
amniote_tree_ages <- amniote_tree_o[[2]]

```

and one lonely frog



```{r amniote v frog, include=TRUE}
##That one ambhibian was dropped in updated COMADRE database
amp_names <- full_uni[full_uni$taxonomic_class %in% c("Amphibia"),"species_two"]
tetra_tree <-  bind_single(tree = amniote_tree, species = amp_names, sample = sample.no, root.age = 359.2)
```

next the fish
```{r tetrapod v fish, include=TRUE}

fish_data <- full_uni[full_uni$taxonomic_class %in% c("Actinopterygii"),]

fish_tree <- comparative.data(phy = met_tree, data = fish_data, names.col = "species_match" , force.root = TRUE)
tree_fish <-compute.brlen(fish_tree$phy, method = "Grafen", power = 1)

##Need to get a sensable split. age should be at lungfish or somerthing
tree_fish $edge.length <- tree_fish $edge.length*418.5


fish_tetrapod_tree_o <- jiggle.bind(x = tetra_tree, 
                            y = tree_fish, 
                            sample = sample.no, 
                            min.age = 419, max.age = 419)
fish_tetrapod_tree <- fish_tetrapod_tree_o[[1]]
fish_tetrapod_tree_ages <- fish_tetrapod_tree_o[[2]]

##I need to add in the one Elasmobranch
shark_names <- full_uni[full_uni$taxonomic_class %in% c("Elasmobranchii"),"species_two"]
deuterostome_tree <-  bind_single(tree = fish_tetrapod_tree, species = shark_names, sample = sample.no, root.age = 420)


```


Now just the rest of the Bilaterial animals

```{r verts v anything else with a brain, include=TRUE}
proto_animals  <- full_uni[full_uni$taxonomic_class %in% c("Bivalvia", "Gastropoda",
                                               "Insecta", "Malacostraca"),]
bi_tree <- comparative.data(phy = met_tree, data = proto_animals, 
                            names.col = "species_match", 
                            force.root = TRUE)

bi_tree <-compute.brlen(bi_tree$phy, method = "Grafen", power = 1)
bi_tree $edge.length <- bi_tree $edge.length*550

bilateral_tree_o <- jiggle.bind(x = deuterostome_tree, 
                                  y = bi_tree, 
                                  sample = sample.no, 
                                  min.age = 555, max.age = 558)

bilateral_tree <- bilateral_tree_o[[1]]
bilateral_tree_ages <- bilateral_tree_o[[2]]
```


nest add the corals
```{r anything else with a brain v coral and a sponge, include=TRUE}
##I need to add in the one Antozoa
coral_names <- full_uni[full_uni$taxonomic_class %in% c("Anthozoa"),"species_two"]
two_tissue_tree <-  bind_single(tree = bilateral_tree, species = coral_names, sample = sample.no, root.age = 560)

##I need to add in the one sponge
sponge_names <- full_uni[full_uni$taxonomic_class %in% c("Demospongiae"),"species_two"]
animal_tree <-  bind_single(tree = two_tissue_tree, species = sponge_names, sample = sample.no, root.age = 800)

```


next we check if the trees are behaving with no jumping forward in time with the nodes.
```{r checking the trees, include=TRUE}

final_tree<- list()
for(i in 1:(length(animal_tree))){
  animal_tree[[i]]$node.label = "NA"
}

##Now we clean each of the trees so it only has COMADRE species in it.
for(i in 1:(length(animal_tree))){
  final_tree[[i]] <- comparative.data(phy = animal_tree[[i]], data = full_uni, names.col = "species_two" , force.root = TRUE)$phy
}


###check that the ancestral nodes dont jump forward in time
###first put the ages with youngest in row 1 an doldest in the last row
node_bind_ages <- rbind(croc_bird_ages, turt_bird_ages, liz_turt_bird_ages, 
                        amniote_tree_ages, fish_tetrapod_tree_ages, bilateral_tree_ages)



###check each colunm is monotonsly increasing
mono_tim <- vector()
for(i in 1:sample.no){ 
  mono_tim[i] <-  all(node_bind_ages[,i] == cummax(node_bind_ages[,i]))
}
mono_tim <- data.frame(mono_tim, row_names = 1:sample.no)
mono_clean <- mono_tim[mono_tim[,1] == TRUE, "row_names"]

##now make a list of the clean trees
final_clean_trees <- list()
for(i in 1:length(mono_clean)){
  final_clean_trees[[i]] <- final_tree[[mono_clean[i]]]
}

```

finaly we rename the tips so that they will match the COMADRE species names for the rest of the analysis

```{r finishing the deed, include=TRUE}
##now lets rename the tips back to match the COMADRE species
for(k in 1:length(mono_clean)){
  renamed_temp <- final_clean_trees[[k]]
  for(i in 1:(length(renamed_temp$tip.label))){
    if(any(renamed_temp$tip.label[i] == full_uni$species_match)){
      final_clean_trees[[k]]$tip.label[i] <-  gsub(" ", "_",full_uni[renamed_temp$tip.label[i] == full_uni$species_match,"species"])
    } 
}
}




for(k in 1:length(final_clean_trees)){
  
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Thalassarche_melanophrys"] <- "Thalassarche_melanophris"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Physeter_catodon"] <- "Physeter_macrocephalus"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Spermophilus_armatus"] <- "Urocitellus_armatus"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Spermophilus_columbianus"] <- "Urocitellus_columbianus"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Grus_paradisea"] <- "Anthropoides_paradiseus"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Dendroica_cerulea"] <- "Setophaga_cerulea"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Sterna_antillarum"] <- "Sternula_antillarum"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Rhinoplocephalus_nigrescens"] <- "Cryptophis_nigrescens"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Drymarchon_corais"] <- "Drymarchon_couperi"
final_clean_trees[[k]]$tip.label[final_clean_trees[[k]]$tip.label == "Hoplocephalus_bitorquatus"] <- "Hoplocephalus_bungaroides"

}


#small fix on ultrametric problem
is_ultra <- vector()
for(i in 1:length(final_clean_trees)) { 
  is_ultra[i] <- is.ultrametric(final_clean_trees[[i]])
  }

ultra_row <- which(is_ultra ==TRUE)

final_clean_trees_ultra <- final_clean_trees[ultra_row]


##lets take the first 100
final_clean_trees <- final_clean_trees_ultra[1:100]

```


and we read out our lovely clean multiphylo object.
```{r Hurayy, include=TRUE}

class(final_clean_trees) <- "multiPhylo"


write.tree(phy = final_clean_trees, file = "COMADRE_100_phylo_feb_2019.tre" )

```